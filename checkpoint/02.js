const Stack = require("../DS").Stack;
// ‚ö†Ô∏è NO MODIFICAR NADA POR ENCIMA DE ESTA L√çNEA ‚ö†Ô∏è
//
//
//
//
// 2Ô∏è‚É£ ***** EJERCICIO 2 STACK***** - apilarPantalones() 2Ô∏è‚É£
//
// Un cliente ha solicitado pantalones de una talla determinada. Es necesario ir a buscar al inventario los pantalones y obtener
// las prendas solicitadas seg√∫n su talla
// Para esto, tendr√°s que implementar la funci√≥n üëñ apilarPantalones üëñ, la cual recibir√° por par√°metros un arreglo
// conteniendo multiples tallas, adem√°s de un n√∫mero de talla a solicitar.
// Deber√°s retornar un objeto, el cual contendr√° una nueva pila
// con los pantalones solicitados y el arreglo anterior con los pantalones restantes
// EJEMPLOS:
// Dado el siguiente arreglo (INPUT): [37, 38, 38, 39, 41, 36, 41, 41, 37, 42]
// apilarPantalones(arreglo, 38) Devuelve (OUTPUT) ‚û°
// {
//   pantalonesEncontrados: Stack([38, 38]),
//   pantalonesRestantes: Stack([37, 39, 41, 36, 41, 41, 37, 42])
// }
// REQUISITOS:
//  üü¢ Respetar el principio de LIFO que tienen los stacks
//  üü¢ Retornar un objeto que contenga:
//  - Una propiedad "pantalonesEncontrados" que sea un stack que contenga los pantalones con la talla solicitada
//  - Una propiedad "pantalonesRestantes" que sea un stack que contenga los pantalones restantes
//  üü¢ Retornar false si el stack viene vac√≠o

function apilarPantalones(array, talla) {
  // Tu c√≥digo aqu√≠:

  if (array.length <= 0) return false;
  const respuesta = {};
  const pantalonesEncontrados = new Stack();
  const pantalonesRestantes = new Stack();
  while (array.length > 0) {
    let actual = array.shift();
    actual === talla
      ? pantalonesEncontrados.push(actual)
      : pantalonesRestantes.push(actual);
  }
  respuesta["pantalonesEncontrados"] = pantalonesEncontrados;
  respuesta["pantalonesRestantes"] = pantalonesRestantes;
  return respuesta;
}

// ‚ö†Ô∏è NO MODIFICAR NADA POR DEBAJO DE ESTA L√çNEA ‚ö†Ô∏è
module.exports = {
  apilarPantalones,
};
